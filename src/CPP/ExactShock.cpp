#include "Riemann.hh"

using namespace std;

//! Initial set up
/*! 
  without any parameters
 */
SHOCK::SHOCK()
{  
  ;
}

//! Initial set up the shock tube condition
/*! 
  
  \param qL1 density of left side
  \param qL2 velocity of left side
  \param qL3 pressure of left side
  \param qR1 density of right side
  \param qR2 velocity of right side
  \param qR3 pressure of right side
*/
SHOCK::SHOCK(REAL qL1, REAL qL2, REAL qL3, REAL qR1, REAL qR2, REAL qR3)
{
  //clear the variables
  xL=xC=xR=0.0;
  rhoL=uL=pL=rhoR=uR=pR=0.0;
  rho_star=u_star=p_star=0.0;
  rho_star_L=rho_star_R=0.0;
  cL=cR=c=0.0;
  c_star_L=c_star_R=0.0;
  sL=sR=sHL=sTL=sHR=sTR=0.0;

  //set the left state
  rhoL=qL1;
  uL=qL2;
  pL=qL3;

  //set the right state
  rhoR=qR1;
  uR=qR2;
  pR=qR3;

  //compute speed of sound
  cL=sqrt(GAMMA*pL/rhoL);
  cR=sqrt(GAMMA*pR/rhoR);

  //compute du=uR-uL;
  du=uR-uL;
}

SHOCK::~SHOCK()
{
  cout<<"Done in SHOCK"<<endl;
}

//! set up the shock tube condition
/*! 
  
  \param qL1 density of left side
  \param qL2 velocity of left side
  \param qL3 pressure of left side
  \param qR1 density of right side
  \param qR2 velocity of right side
  \param qR3 pressure of right side
*/
void SHOCK::Set(REAL qL1, REAL qL2, REAL qL3, REAL qR1, REAL qR2, REAL qR3)
{
  //clear the variables
  xL=xC=xR=0.0;
  rhoL=uL=pL=rhoR=uR=pR=0.0;
  rho_star=u_star=p_star=0.0;
  rho_star_L=rho_star_R=0.0;
  cL=cR=c=0.0;
  c_star_L=c_star_R=0.0;
  sL=sR=sHL=sTL=sHR=sTR=0.0;

  //set the left state
  rhoL=qL1;
  uL=qL2;
  pL=qL3;

  //set the right state
  rhoR=qR1;
  uR=qR2;
  pR=qR3;

  //compute speed of sound
  cL=sqrt(GAMMA*pL/rhoL);
  cR=sqrt(GAMMA*pR/rhoR);

  //compute du=uR-uL;
  du=uR-uL;
}


void SHOCK::Display()
{

  printf("\nLeft :(%f %f %f) --- Right:(%f %f %f)\n",rhoL,uL,pL,rhoR,uR,pR);
  
  printf("\tp*=%7.5f, u*=%7.5f, d*L=%7.5f, d*R=%7.5f\n",p_star,u_star,rho_star_L,rho_star_R);

  printf("\trho_star_L=%f, rho_star_R=%f\n",rho_star_L,rho_star_R);

  printf("\tc_star_L=%f, c_star_R=%f\n",c_star_L,c_star_R);
  printf("\tsL=%f, sR=%f\n",sL,sR);
  printf("\tsHL=%f, sTL=%f\n",sHL,sTL);
  printf("\tsHR=%f, sTR=%f\n",sHR,sTR);
  // cout<<"p="<<p
  //     <<"\tu="<<u
  //     <<"\trho_star_L="<<rho_star_L
  //     <<"\trho_star_R="<<rho_star_R
  //     <<endl;
}

/** 
 * compute the pressure and u
 * 
 */
void SHOCK::Pressure_U()
{
  REAL TOL=1.0e-6;
  INTEGER NRITER=20;

  //compute critical velocity
  REAL ducrit=G4*(cL+cR)-du;

  //check for vacuum
  if(ducrit<=0.0)
    {
      cout<<"Vacuum is generated by given data";
      exit(1);
    }

  //guess a value of p
  REAL p;
  STARTE(p);

  REAL p0=p;

  //iteration to compute p
  REAL FL,FLD;
  REAL FR,FRD;
  INTEGER k;
  for(k=0;k<NRITER;k++)
    {
      PREFUN(FL,FLD,p,rhoL,pL,cL);
      PREFUN(FR,FRD,p,rhoR,pR,cR);
      p=p-(FL+FR+du)/(FLD+FRD);
      REAL CHA=2.0*fabs((p-p0)/(p+p0));
      if(CHA<=TOL) break;
      if(p<0.0) p=TOL;
      p0=p;
      // cout<<"k="<<k
      //     <<"\tp="<<p<<endl;
    }  
  //
#ifdef SCREENSHOW
  cout<<"inner iteration="<<k<<endl;
#endif

  p_star=p;
  
  //compute u
  u_star=0.5*(uL+uR+FR-FL);

}

void SHOCK::PREFUN(REAL& F, REAL& FD, REAL P, REAL DK, REAL PK, REAL CK)
{
  if(P<=PK)                     /**< rarefaction wave */
    {
      REAL PRAT=P/PK;
      F=G4*CK*(pow(PRAT,G1)-1.0);
      FD=(1.0/(DK*CK))*pow(PRAT,-G2);
    }
  else                          /**< shock wave */
    {
      REAL AK=G5/DK;
      REAL BK=G6*PK;
      REAL QRT=sqrt(AK/(BK+P));
      F=(P-PK)*QRT;
      FD=(1.0-0.5*(P-PK)/(BK+P))*QRT;
    }
}
/** 
 * hybrid starter using pvrs, trrs and tsrs
 * 
 * @param p 
 */
void SHOCK::STARTE(REAL& p)
{
  REAL TOL=1.0e-6;
  INTEGER QMAX=2.0;

  //compute guess value from pvrs
  REAL pV=0.5*(pL+pR)-0.125*(uR-uL)*(rhoL+rhoR)*(cL+cR);
  REAL pMin=min(pL,pR);
  REAL pMax=max(pL,pR);
  REAL QRAT=pMax/pMin;

  if(QRAT<=QMAX&&(pMin<=pV&&pV<=pMax)){
    //use pvrs solution as guess
    p=max(TOL,pV);
  }
  else{
    if(pV<pMin){
      //use two-rarefaction solution
      REAL pNU=cL+cR-G7*(uR-uL);
      REAL pDE=cL/pow(pL,G1)+cR/pow(pR,G1);
      p=pow((pNU/pDE),G3);
    }
    else{
      //two-shock approximation with pv as estimate
      REAL GEL=sqrt((G5/rhoL)/(G6*pL+max(TOL,pV)));
      REAL GER=sqrt((G5/rhoR)/(G6*pR+max(TOL,pV)));
      p=(GEL*pL+GER*pR-(uR-uL))/(GEL+GER);
      p=max(TOL,p);
    }
  }
}

//! solve the density
/*! 
  
 */
void SHOCK::Density()
{
  // star left state
  REAL fL=p_star/pL;

  if(fL>1){
    //p_star>pL, left shock wave
    rho_star_L=rhoL*((fL+G6)/(fL*G6+1)); /*!< density */
    
    sL=uL-cL*sqrt(G2*fL+G1);    /*!< shock speed */
  }
  else{
    //p_star<=pL, left rarefaction wave
    rho_star_L=rhoL*pow(fL,G8); /*!< density */

    c_star_L=cL*pow(fL,G1);     /*!< speed of sound */

    sHL=uL-cL;                  /*!< head speed */
    sTL=u_star-c_star_L;        /*!< tail speed */
  }

  // star right state
  REAL fR=p_star/pR;
  if(fR>1){
    //p_star>pR, right shock wave
    rho_star_R=rhoR*(fR+G6)/(fR*G6+1); /*!< density */


    
    sR=uR+cR*sqrt(G2*fR+G1);    /*!< shock speed */
  }
  else{
    //p_star<=pR, right rarefaction wave
    rho_star_R=rhoR*pow(fR,G8);
    c_star_R=cR*pow(fR,G1);     /*!< speed of sound */
    sHR=uR+cR;
    sTR=u_star+c_star_R;
  }
}


//! compute U(x,t)
/*! 
  
  \param x   x coordinate
  \param t   time
  \param rho density
  \param u   velocity component u
  \param p   pressure
*/
void SHOCK::Sample(REAL x, REAL t, REAL &rho, REAL &u, REAL &p, REAL &e)
{
  REAL S=x/t;
  
  if(t<1e-10) {S=0.0;}


  if(t<1e-10)
    {
      if(x>0){
      //right state
      rho=rhoR;
      u=uR;
      p=pR;
      e=p/G9/rho;
      return;
    }
    else if(x<0)
      {//left state
        rho=rhoL;
        u=uL;
        p=pL;
        e=p/G9/rho;
        return;
      }
    }
    
    
  
  {

    // bool find=0;
    // if(fabs(x-0.05)<0.01||fabs(x+0.05)<0.01)
    //   {
    //     cout<<"x="<<x
    //         <<"\nS="<<S
    //         <<"\nu_star="<<u_star<<endl;
    //     find=1;
    //   }

    if(S<=u_star){
      // sample point is to the left of the contact
      // if(find) cout<<"\nS="<<S<<" sTL="<<sTL<<endl;
      // if(find) cout<<"\nleft of the contact";
      if(p_star<=pL){
        // left rarefaction wave      
        REAL SHL=uL-cL;
        if(S<=SHL){
          // left data state
          rho = rhoL;
          u   = uL;
          p   = pL;
          // if(find) cout<<"->left rare";
        }
        else{
          REAL CML=cL*pow((p_star/pL),G1);
          REAL STL=u_star-CML;
          if(S>STL){
            // middle left state
            rho=rhoL*pow((p_star/pL),G8);
            u=u_star;
            p=p_star;
            // if(find) cout<<"->middle left state";
          }
          else{
            // an left state (inside fan)
            u=G5*(cL+G7*uL+S);
            REAL c=G5*(cL+G7*(uL-S));
            rho=rhoL*pow((c/cL),G4);
            p=pL*pow((c/cL),G3);
            // if(find) cout<<"-> an left state(inside fan)";
          }
        }
      }
      else{
        // left shock wave
        REAL PML=p_star/pL;
        REAL SL=uL-cL*sqrt(G2*PML+G1);
        if(S<=SL){
          //left data state
          rho=rhoL;
          u=uL;
          p=pL;
        }
        else{
          //middle left state (behind shock)
          // rho=rho_star_L;
          rho=rhoL*(PML+G6)/(PML*G6+1.0);
          u=u_star;
          p=p_star;
        }    
      }
    }
    else{
      // sample point is to the right of the contact
      // if(find) cout<<"\nS="<<S<<" sTR="<<sTR<<endl;
      // if(find) cout<<"\nright of the contact";
      if(p_star>pR){
        //right shock
        // if(find) cout<<"-> right shock";
        REAL PMR=p_star/pR;
        REAL SR=uR+cR*sqrt(G2*PMR+G1);
        if(S>=SR){
          //right data state
          rho=rhoR;
          u=uR;
          p=pR;
          // if(find) cout<<"-> right data state";
        }
        else{
          //middle right state (behind shock)
          // rho=rho_star_R;
          rho=rhoR*(PMR+G6)/(PMR*G6+1.0);
          u=u_star;
          p=p_star;
          // if(find) cout<<"-> middle right state (behind shock)";
        }
      }
      else{
        //right fan
        // if(find) cout<<"->right fan";
        REAL SHR=uR+cR;
        if(S>=SHR){
          //right data state
          rho=rhoR;
          u=uR;
          p=pR;
          // if(find) cout<<"-> right data state"<<endl;
        }
        else{
          REAL CMR=cR*pow((p_star/pR),G1);
          REAL STR=u_star+CMR;
          if(S<=STR){
            //middle right state
            rho=rho_star_R;
            u=u_star;
            p=p_star;
            // if(find) cout<<"-> middle right state"<<endl;
          }
          else{
            //fan right state (inside fan)
            u=G5*(-cR+G7*uR+S);
            REAL c=G5*(cR-G7*(uR-S));
            rho=rhoR*pow((c/cR),G4);
            p=pR*pow((c/cR),G3);

            // if(find) cout<<"-> fan right state (inside fan)";
          }
        }
      }
    }
  }
  // if(find) cout<<"\nrho="<<rho<<"\tu="<<u<<"\tp="<<p<<endl;

  e=p/G9/rho;
}


//! compute the exact Riemann solution
/*! 
  
  \param x0 left bound
  \param x1 right bound
  \param t time
*/
void SHOCK::ExactRiemann(REAL x0, REAL x1, REAL t)
{
  Pressure_U();
  Density();
  Display();
  const INTEGER N=10001;
  REAL rho[N+1],u[N+1],p[N+1],e[N+1],x[N+1];

  cout<<"t="<<t<<endl;

  REAL dx=(x1-x0)/N;
  for(INTEGER i=0;i<=N;i++)
    {
      x[i]=x0+i*dx;       
      Sample(x[i],t,rho[i],u[i],p[i],e[i]);
    }

  //output the file
  ofstream ft;
  ft.open("Sod_X_Exact.dat");
  for(INTEGER i=0;i<=N;i++)
    {
      ft<<x[i]<<" "
        <<rho[i]<<" "
        <<u[i]<<" "
        <<p[i]<<" "
        <<e[i]<<endl;

    }
  ft.close();
}

//! solve a local Riemann problem
/*! 
  
  \param qL1 Left state density
  \param qL2 Left state velocity
  \param qL3 Left state pressure
  \param qR1 Right state density
  \param qR2 Right state velocity
  \param qR3 Right state pressure
  \param q1  solution density
  \param q2  solution velocity
  \param q3  solution pressure
  \param q4  solution energy
*/
void SHOCK::LocalRiemann(REAL qL1, REAL qL2, REAL qL3,
                         REAL qR1, REAL qR2, REAL qR3,
                         REAL &q1, REAL &q2, REAL &q3, REAL &q4)
{
  //set up the local Riemann problem for a local shock tube
  Set(qL1,qL2,qL3,qR1,qR2,qR3);

  //compute the middle state pressure p* and velocity u*
  Pressure_U();

  //compute the middle left state density rho_star_L and 
  //            middle right state density rho_star_R
  Density();

  //set the local coordinate system
  REAL x=0.0; 
  REAL t=0;
  
  //compute the local Riemann solution
  Sample(x,t,q1,q2,q3,q4);
}
